{
  "code_examples": [
    {
      "input": "import asyncio\nimport concurrent.futures\nimport time\nfrom typing import List, Dict, Optional\nfrom uuid import uuid4\n\nclass MySQLDatabase:\n    def __init__(self, connection_string: str, connection_properties: Dict[str, str]):\n        self.connection_string = connection_string\n        self.connection_properties = connection_properties\n        self.is_connected = False\n        self.connection_timeout = 30\n        self.connection_pool = concurrent.futures.ThreadPoolExecutor(max_workers=10)\n    \n    async def connect(self):\n        if not self.is_connected:\n            print(f\"Establishing MySQL connection with: {self.connection_string}\")\n            await asyncio.sleep(self.connection_timeout / 1000)\n            self.is_connected = True\n            print(\"MySQL connection established successfully\")\n    \n    def disconnect(self):\n        if self.is_connected:\n            print(\"Closing MySQL connection\")\n            self.is_connected = False\n            self.connection_pool.shutdown()\n    \n    async def get_user_email(self, user_id: int) -> str:\n        if not self.is_connected:\n            raise RuntimeError(\"Database connection not established\")\n        \n        loop = asyncio.get_event_loop()\n        future = self.connection_pool.submit(self._fetch_user_email, user_id)\n        return await loop.run_in_executor(None, future.result, 5)\n    \n    def _fetch_user_email(self, user_id: int) -> str:\n        time.sleep(0.01)\n        return f\"user{user_id}@enterprise.com\"\n    \n    async def validate_user(self, user_id: int) -> bool:\n        if not self.is_connected:\n            raise RuntimeError(\"Database connection not established\")\n        \n        loop = asyncio.get_event_loop()\n        future = self.connection_pool.submit(self._validate_user_internal, user_id)\n        return await loop.run_in_executor(None, future.result, 3)\n    \n    def _validate_user_internal(self, user_id: int) -> bool:\n        time.sleep(0.005)\n        return user_id > 0 and user_id < 100000\n    \n    async def get_user_groups(self, user_id: int) -> List[str]:\n        if not self.is_connected:\n            raise RuntimeError(\"Database connection not established\")\n        \n        loop = asyncio.get_event_loop()\n        future = self.connection_pool.submit(self._fetch_user_groups, user_id)\n        return await loop.run_in_executor(None, future.result, 10)\n    \n    def _fetch_user_groups(self, user_id: int) -> List[str]:\n        time.sleep(0.015)\n        return [\"general\", f\"department_{user_id % 10}\"]\n    \n    async def update_email_sent_status(self, user_id: int, message_id: str):\n        if not self.is_connected:\n            raise RuntimeError(\"Database connection not established\")\n        \n        loop = asyncio.get_event_loop()\n        future = self.connection_pool.submit(self._update_status, user_id, message_id)\n        await loop.run_in_executor(None, future.result)\n    \n    def _update_status(self, user_id: int, message_id: str):\n        time.sleep(0.02)\n        print(f\"Email status updated for user {user_id}, message: {message_id}\")\n\nclass EmailService:\n    def __init__(self, smtp_server: str, smtp_port: int, username: str, password: str, use_ssl: bool):\n        self.smtp_server = smtp_server\n        self.smtp_port = smtp_port\n        self.smtp_username = username\n        self.smtp_password = password\n        self.use_ssl = use_ssl\n        \n        db_properties = {\n            \"useSSL\": \"true\",\n            \"serverTimezone\": \"UTC\"\n        }\n        \n        self.database = MySQLDatabase(\"mysql://localhost:3306/enterprise_users?useSSL=true&serverTimezone=UTC\", db_properties)\n    \n    async def send_email(self, user_id: int, subject: str, message: str, priority: str):\n        await self.database.connect()\n        \n        try:\n            if not await self.database.validate_user(user_id):\n                print(f\"User validation failed for ID: {user_id}\")\n                return\n            \n            email = await self.database.get_user_email(user_id)\n            groups = await self.database.get_user_groups(user_id)\n            \n            print(\"Configuring SMTP connection:\")\n            print(f\"Server: {self.smtp_server}:{self.smtp_port}\")\n            print(f\"SSL: {self.use_ssl}\")\n            print(f\"Authentication: {self.smtp_username}\")\n            \n            message_id = str(uuid4())\n            \n            print(\"Sending email:\")\n            print(f\"To: {email}\")\n            print(f\"Subject: {subject}\")\n            print(f\"Message: {message}\")\n            print(f\"Priority: {priority}\")\n            print(f\"User Groups: {groups}\")\n            print(f\"Message ID: {message_id}\")\n            \n            await self.database.update_email_sent_status(user_id, message_id)\n            \n        finally:\n            self.database.disconnect()\n    \n    async def send_bulk_emails(self, user_ids: List[int], subject: str, message: str, priority: str):\n        await self.database.connect()\n        \n        try:\n            tasks = []\n            for user_id in user_ids:\n                tasks.append(self._send_single_bulk_email(user_id, subject, message, priority))\n            \n            await asyncio.gather(*tasks)\n            \n        finally:\n            self.database.disconnect()\n    \n    async def _send_single_bulk_email(self, user_id: int, subject: str, message: str, priority: str):\n        try:\n            if await self.database.validate_user(user_id):\n                email = await self.database.get_user_email(user_id)\n                groups = await self.database.get_user_groups(user_id)\n                message_id = str(uuid4())\n                \n                print(f\"Bulk email sent to: {email} (Groups: {groups})\")\n                await self.database.update_email_sent_status(user_id, message_id)\n        except Exception as e:\n            print(f\"Failed to send email to user {user_id}: {e}\")\n    \n    async def send_scheduled_emails(self, user_messages: Dict[int, str], subject: str, delay_seconds: int):\n        await self.database.connect()\n        \n        try:\n            for user_id, personalized_message in user_messages.items():\n                await asyncio.sleep(delay_seconds)\n                \n                try:\n                    if await self.database.validate_user(user_id):\n                        email = await self.database.get_user_email(user_id)\n                        groups = await self.database.get_user_groups(user_id)\n                        message_id = str(uuid4())\n                        \n                        print(f\"Scheduled email sent to: {email}\")\n                        print(f\"Personalized message: {personalized_message}\")\n                        await self.database.update_email_sent_status(user_id, message_id)\n                except Exception as e:\n                    print(f\"Failed to send scheduled email to user {user_id}: {e}\")\n                    \n        finally:\n            self.database.disconnect()",
      "output": "import asyncio\nimport concurrent.futures\nimport time\nfrom abc import ABC, abstractmethod\nfrom typing import List, Dict, Optional\nfrom uuid import uuid4\n\nclass DatabaseService(ABC):\n    @abstractmethod\n    async def connect(self):\n        pass\n    \n    @abstractmethod\n    def disconnect(self):\n        pass\n    \n    @abstractmethod\n    async def get_user_email(self, user_id: int) -> str:\n        pass\n    \n    @abstractmethod\n    async def validate_user(self, user_id: int) -> bool:\n        pass\n    \n    @abstractmethod\n    async def get_user_groups(self, user_id: int) -> List[str]:\n        pass\n    \n    @abstractmethod\n    async def update_email_sent_status(self, user_id: int, message_id: str):\n        pass\n\nclass MySQLDatabase(DatabaseService):\n    def __init__(self, connection_string: str, connection_properties: Dict[str, str]):\n        self.connection_string = connection_string\n        self.connection_properties = connection_properties\n        self.is_connected = False\n        self.connection_timeout = 30\n        self.connection_pool = concurrent.futures.ThreadPoolExecutor(max_workers=10)\n    \n    async def connect(self):\n        if not self.is_connected:\n            print(f\"Establishing MySQL connection with: {self.connection_string}\")\n            await asyncio.sleep(self.connection_timeout / 1000)\n            self.is_connected = True\n            print(\"MySQL connection established successfully\")\n    \n    def disconnect(self):\n        if self.is_connected:\n            print(\"Closing MySQL connection\")\n            self.is_connected = False\n            self.connection_pool.shutdown()\n    \n    async def get_user_email(self, user_id: int) -> str:\n        if not self.is_connected:\n            raise RuntimeError(\"Database connection not established\")\n        \n        loop = asyncio.get_event_loop()\n        future = self.connection_pool.submit(self._fetch_user_email, user_id)\n        return await loop.run_in_executor(None, future.result, 5)\n    \n    def _fetch_user_email(self, user_id: int) -> str:\n        time.sleep(0.01)\n        return f\"user{user_id}@enterprise.com\"\n    \n    async def validate_user(self, user_id: int) -> bool:\n        if not self.is_connected:\n            raise RuntimeError(\"Database connection not established\")\n        \n        loop = asyncio.get_event_loop()\n        future = self.connection_pool.submit(self._validate_user_internal, user_id)\n        return await loop.run_in_executor(None, future.result, 3)\n    \n    def _validate_user_internal(self, user_id: int) -> bool:\n        time.sleep(0.005)\n        return user_id > 0 and user_id < 100000\n    \n    async def get_user_groups(self, user_id: int) -> List[str]:\n        if not self.is_connected:\n            raise RuntimeError(\"Database connection not established\")\n        \n        loop = asyncio.get_event_loop()\n        future = self.connection_pool.submit(self._fetch_user_groups, user_id)\n        return await loop.run_in_executor(None, future.result, 10)\n    \n    def _fetch_user_groups(self, user_id: int) -> List[str]:\n        time.sleep(0.015)\n        return [\"general\", f\"department_{user_id % 10}\"]\n    \n    async def update_email_sent_status(self, user_id: int, message_id: str):\n        if not self.is_connected:\n            raise RuntimeError(\"Database connection not established\")\n        \n        loop = asyncio.get_event_loop()\n        future = self.connection_pool.submit(self._update_status, user_id, message_id)\n        await loop.run_in_executor(None, future.result)\n    \n    def _update_status(self, user_id: int, message_id: str):\n        time.sleep(0.02)\n        print(f\"Email status updated for user {user_id}, message: {message_id}\")\n\nclass EmailService:\n    def __init__(self, smtp_server: str, smtp_port: int, username: str, password: str, use_ssl: bool, database: DatabaseService):\n        self.smtp_server = smtp_server\n        self.smtp_port = smtp_port\n        self.smtp_username = username\n        self.smtp_password = password\n        self.use_ssl = use_ssl\n        self.database = database\n    \n    async def send_email(self, user_id: int, subject: str, message: str, priority: str):\n        await self.database.connect()\n        \n        try:\n            if not await self.database.validate_user(user_id):\n                print(f\"User validation failed for ID: {user_id}\")\n                return\n            \n            email = await self.database.get_user_email(user_id)\n            groups = await self.database.get_user_groups(user_id)\n            \n            print(\"Configuring SMTP connection:\")\n            print(f\"Server: {self.smtp_server}:{self.smtp_port}\")\n            print(f\"SSL: {self.use_ssl}\")\n            print(f\"Authentication: {self.smtp_username}\")\n            \n            message_id = str(uuid4())\n            \n            print(\"Sending email:\")\n            print(f\"To: {email}\")\n            print(f\"Subject: {subject}\")\n            print(f\"Message: {message}\")\n            print(f\"Priority: {priority}\")\n            print(f\"User Groups: {groups}\")\n            print(f\"Message ID: {message_id}\")\n            \n            await self.database.update_email_sent_status(user_id, message_id)\n            \n        finally:\n            self.database.disconnect()\n    \n    async def send_bulk_emails(self, user_ids: List[int], subject: str, message: str, priority: str):\n        await self.database.connect()\n        \n        try:\n            tasks = []\n            for user_id in user_ids:\n                tasks.append(self._send_single_bulk_email(user_id, subject, message, priority))\n            \n            await asyncio.gather(*tasks)\n            \n        finally:\n            self.database.disconnect()\n    \n    async def _send_single_bulk_email(self, user_id: int, subject: str, message: str, priority: str):\n        try:\n            if await self.database.validate_user(user_id):\n                email = await self.database.get_user_email(user_id)\n                groups = await self.database.get_user_groups(user_id)\n                message_id = str(uuid4())\n                \n                print(f\"Bulk email sent to: {email} (Groups: {groups})\")\n                await self.database.update_email_sent_status(user_id, message_id)\n        except Exception as e:\n            print(f\"Failed to send email to user {user_id}: {e}\")\n    \n    async def send_scheduled_emails(self, user_messages: Dict[int, str], subject: str, delay_seconds: int):\n        await self.database.connect()\n        \n        try:\n            for user_id, personalized_message in user_messages.items():\n                await asyncio.sleep(delay_seconds)\n                \n                try:\n                    if await self.database.validate_user(user_id):\n                        email = await self.database.get_user_email(user_id)\n                        groups = await self.database.get_user_groups(user_id)\n                        message_id = str(uuid4())\n                        \n                        print(f\"Scheduled email sent to: {email}\")\n                        print(f\"Personalized message: {personalized_message}\")\n                        await self.database.update_email_sent_status(user_id, message_id)\n                except Exception as e:\n                    print(f\"Failed to send scheduled email to user {user_id}: {e}\")\n                    \n        finally:\n            self.database.disconnect()",
      "level": "HARD",
      "language": "PYTHON",
      "violation": "DIP",
      "explanation": "EmailService creates and depends directly on MySQLDatabase and its connection details. No abstraction boundary or inversion exists; high-level policy is coupled to low-level storage and pool behavior. Swapping databases or testing requires editing EmailService, not supplying an abstraction.",
      "adherence_score": 1,
      "violation_severity": 4
    },
    {
      "input": "public class PayPalGateway {\n    public boolean processPayment(double amount) {\n        System.out.println(\"Processing $\" + amount + \" via PayPal\");\n        return true;\n    }\n}\n\npublic class PaymentProcessor {\n    private PayPalGateway paypalGateway;\n    \n    public PaymentProcessor() {\n        this.paypalGateway = new PayPalGateway();\n    }\n    \n    public boolean processTransaction(double amount) {\n        return paypalGateway.processPayment(amount);\n    }\n}",
      "output": "public interface PaymentGateway {\n    boolean processPayment(double amount);\n}\n\npublic class PayPalGateway implements PaymentGateway {\n    public boolean processPayment(double amount) {\n        System.out.println(\"Processing $\" + amount + \" via PayPal\");\n        return true;\n    }\n}\n\npublic class PaymentProcessor {\n    private PaymentGateway paymentGateway;\n    \n    public PaymentProcessor(PaymentGateway paymentGateway) {\n        this.paymentGateway = paymentGateway;\n    }\n    \n    public boolean processTransaction(double amount) {\n        return paymentGateway.processPayment(amount);\n    }\n}",
      "level": "EASY",
      "language": "JAVA",
      "violation": "DIP",
      "explanation": "PaymentProcessor constructs and depends on PayPalGateway directly. There is no abstraction or injection; the high-level module is tied to one concrete implementation. Replacing gateways or unit testing requires editing PaymentProcessor, indicating a straightforward DIP and IoC violation.",
      "adherence_score": 1,
      "violation_severity": 4
    },
    {
      "input": "class PayPalGateway:\n    def process_payment(self, amount):\n        print(f\"Processing ${amount} via PayPal\")\n        return True\n\nclass PaymentProcessor:\n    def __init__(self):\n        self.paypal_gateway = PayPalGateway()\n    \n    def process_transaction(self, amount):\n        return self.paypal_gateway.process_payment(amount)",
      "output": "from abc import ABC, abstractmethod\n\nclass PaymentGateway(ABC):\n    @abstractmethod\n    def process_payment(self, amount):\n        pass\n\nclass PayPalGateway(PaymentGateway):\n    def process_payment(self, amount):\n        print(f\"Processing ${amount} via PayPal\")\n        return True\n\nclass PaymentProcessor:\n    def __init__(self, payment_gateway):\n        self.payment_gateway = payment_gateway\n    \n    def process_transaction(self, amount):\n        return self.payment_gateway.process_payment(amount)",
      "level": "EASY",
      "language": "PYTHON",
      "violation": "DIP",
      "explanation": "PaymentProcessor constructs and depends on PayPalGateway directly. There is no abstraction or injection; the high-level module is tied to one concrete implementation. Replacing gateways or unit testing requires editing PaymentProcessor, indicating a straightforward DIP and IoC violation.",
      "adherence_score": 1,
      "violation_severity": 4
    },
    {
      "input": "public class PayPalGateway {\n    public boolean processPayment(double amount, String currency) {\n        System.out.println(\"Processing \" + amount + \" \" + currency + \" via PayPal\");\n        return amount > 0;\n    }\n    \n    public String getTransactionId() {\n        return \"PP_\" + System.currentTimeMillis();\n    }\n}\n\npublic class StripeGateway {\n    public boolean chargeCard(double amount, String currency) {\n        System.out.println(\"Charging \" + amount + \" \" + currency + \" via Stripe\");\n        return amount > 0;\n    }\n    \n    public String getChargeId() {\n        return \"ST_\" + System.currentTimeMillis();\n    }\n}\n\npublic class PaymentProcessor {\n    private PayPalGateway paypalGateway;\n    private StripeGateway stripeGateway;\n    \n    public PaymentProcessor() {\n        this.paypalGateway = new PayPalGateway();\n        this.stripeGateway = new StripeGateway();\n    }\n    \n    public boolean processTransaction(double amount, String currency, String gateway) {\n        if (gateway.equals(\"paypal\")) {\n            boolean result = paypalGateway.processPayment(amount, currency);\n            if (result) {\n                System.out.println(\"Transaction ID: \" + paypalGateway.getTransactionId());\n            }\n            return result;\n        } else if (gateway.equals(\"stripe\")) {\n            boolean result = stripeGateway.chargeCard(amount, currency);\n            if (result) {\n                System.out.println(\"Charge ID: \" + stripeGateway.getChargeId());\n            }\n            return result;\n        }\n        return false;\n    }\n    \n    public void processRefund(double amount, String gateway) {\n        if (gateway.equals(\"paypal\")) {\n            System.out.println(\"Refunding \" + amount + \" via PayPal\");\n        } else if (gateway.equals(\"stripe\")) {\n            System.out.println(\"Refunding \" + amount + \" via Stripe\");\n        }\n    }\n}",
      "output": "public interface PaymentGateway {\n    boolean processPayment(double amount, String currency);\n    String getTransactionId();\n}\n\npublic class PayPalGateway implements PaymentGateway {\n    public boolean processPayment(double amount, String currency) {\n        System.out.println(\"Processing \" + amount + \" \" + currency + \" via PayPal\");\n        return amount > 0;\n    }\n    \n    public String getTransactionId() {\n        return \"PP_\" + System.currentTimeMillis();\n    }\n}\n\npublic class StripeGateway implements PaymentGateway {\n    public boolean processPayment(double amount, String currency) {\n        System.out.println(\"Charging \" + amount + \" \" + currency + \" via Stripe\");\n        return amount > 0;\n    }\n    \n    public String getTransactionId() {\n        return \"ST_\" + System.currentTimeMillis();\n    }\n}\n\npublic class PaymentProcessor {\n    private PaymentGateway paymentGateway;\n    \n    public PaymentProcessor(PaymentGateway paymentGateway) {\n        this.paymentGateway = paymentGateway;\n    }\n    \n    public boolean processTransaction(double amount, String currency) {\n        boolean result = paymentGateway.processPayment(amount, currency);\n        if (result) {\n            System.out.println(\"Transaction ID: \" + paymentGateway.getTransactionId());\n        }\n        return result;\n    }\n    \n    public void processRefund(double amount) {\n        System.out.println(\"Refunding \" + amount + \" via \" + paymentGateway.getClass().getSimpleName());\n    }\n}",
      "level": "MODERATE",
      "language": "JAVA",
      "violation": "DIP",
      "explanation": "PaymentProcessor instantiates two concrete gateways and branches on a string. It depends on low-level details and differing APIs, leaking knowledge of IDs and providers. Adding a new gateway or changing one forces edits to PaymentProcessor, evidencing strong DIP and IoC violations.",
      "adherence_score": 1,
      "violation_severity": 5
    },
    {
      "input": "import time\n\nclass PayPalGateway:\n    def process_payment(self, amount, currency):\n        print(f\"Processing {amount} {currency} via PayPal\")\n        return amount > 0\n    \n    def get_transaction_id(self):\n        return f\"PP_{int(time.time() * 1000)}\"\n\nclass StripeGateway:\n    def charge_card(self, amount, currency):\n        print(f\"Charging {amount} {currency} via Stripe\")\n        return amount > 0\n    \n    def get_charge_id(self):\n        return f\"ST_{int(time.time() * 1000)}\"\n\nclass PaymentProcessor:\n    def __init__(self):\n        self.paypal_gateway = PayPalGateway()\n        self.stripe_gateway = StripeGateway()\n    \n    def process_transaction(self, amount, currency, gateway):\n        if gateway == \"paypal\":\n            result = self.paypal_gateway.process_payment(amount, currency)\n            if result:\n                print(f\"Transaction ID: {self.paypal_gateway.get_transaction_id()}\")\n            return result\n        elif gateway == \"stripe\":\n            result = self.stripe_gateway.charge_card(amount, currency)\n            if result:\n                print(f\"Charge ID: {self.stripe_gateway.get_charge_id()}\")\n            return result\n        return False\n    \n    def process_refund(self, amount, gateway):\n        if gateway == \"paypal\":\n            print(f\"Refunding {amount} via PayPal\")\n        elif gateway == \"stripe\":\n            print(f\"Refunding {amount} via Stripe\")",
      "output": "import time\nfrom abc import ABC, abstractmethod\n\nclass PaymentGateway(ABC):\n    @abstractmethod\n    def process_payment(self, amount, currency):\n        pass\n    \n    @abstractmethod\n    def get_transaction_id(self):\n        pass\n\nclass PayPalGateway(PaymentGateway):\n    def process_payment(self, amount, currency):\n        print(f\"Processing {amount} {currency} via PayPal\")\n        return amount > 0\n    \n    def get_transaction_id(self):\n        return f\"PP_{int(time.time() * 1000)}\"\n\nclass StripeGateway(PaymentGateway):\n    def process_payment(self, amount, currency):\n        print(f\"Charging {amount} {currency} via Stripe\")\n        return amount > 0\n    \n    def get_transaction_id(self):\n        return f\"ST_{int(time.time() * 1000)}\"\n\nclass PaymentProcessor:\n    def __init__(self, payment_gateway):\n        self.payment_gateway = payment_gateway\n    \n    def process_transaction(self, amount, currency):\n        result = self.payment_gateway.process_payment(amount, currency)\n        if result:\n            print(f\"Transaction ID: {self.payment_gateway.get_transaction_id()}\")\n        return result\n    \n    def process_refund(self, amount):\n        print(f\"Refunding {amount} via {self.payment_gateway.__class__.__name__}\")",
      "level": "MODERATE",
      "language": "PYTHON",
      "violation": "DIP",
      "explanation": "PaymentProcessor owns concrete PayPal and Stripe gateways and selects via string flags. High-level logic depends on low-level classes and their differing APIs; provider knowledge and ID formats leak upward. Extending or testing requires editing PaymentProcessor, showing a strong DIP and IoC violation.",
      "adherence_score": 1,
      "violation_severity": 5
    }
  ]
}