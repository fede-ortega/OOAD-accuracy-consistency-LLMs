{
  "code_examples": [
    {
      "input": "class Shape {\n    private String type;\n    \n    public Shape(String type) {\n        this.type = type;\n    }\n    \n    public String getType() {\n        return type;\n    }\n}\n\nclass Rectangle extends Shape {\n    private double width;\n    private double height;\n    \n    public Rectangle(double width, double height) {\n        super(\"rectangle\");\n        this.width = width;\n        this.height = height;\n    }\n    \n    public double getWidth() {\n        return width;\n    }\n    \n    public double getHeight() {\n        return height;\n    }\n}\n\nclass Circle extends Shape {\n    private double radius;\n    \n    public Circle(double radius) {\n        super(\"circle\");\n        this.radius = radius;\n    }\n    \n    public double getRadius() {\n        return radius;\n    }\n}\n\nclass AreaCalculator {\n    public double calculateArea(Shape shape) {\n        if (shape.getType().equals(\"rectangle\")) {\n            Rectangle rectangle = (Rectangle) shape;\n            return rectangle.getWidth() * rectangle.getHeight();\n        } else if (shape.getType().equals(\"circle\")) {\n            Circle circle = (Circle) shape;\n            return Math.PI * circle.getRadius() * circle.getRadius();\n        }\n        return 0;\n    }\n}\n",
      "output": "interface Shape {\n    double getArea();\n}\n\nclass Rectangle implements Shape {\n    private final double width;\n    private final double height;\n\n    public Rectangle(double width, double height) {\n        this.width = width;\n        this.height = height;\n    }\n\n    public double getArea() {\n        return width * height;\n    }\n}\n\nclass Circle implements Shape {\n    private final double radius;\n\n    public Circle(double radius) {\n        this.radius = radius;\n    }\n\n    public double getArea() {\n        return Math.PI * radius * radius;\n    }\n}\n\nclass AreaCalculator {\n    public double calculateArea(Shape shape) {\n        return shape.getArea();\n    }\n}\n",
      "level": "EASY",
      "language": "JAVA",
      "violation": "OCP",
      "explanation": "AreaCalculator violates OCP because it uses explicit if–else checks for each Shape subtype. Whenever a new Shape like Triangle or Polygon is added, the method must be changed.",
          "adherence score": 2,
          "violation severity": 4
    },
    {
      "input": "import java.util.*;\n\nenum CharacterType {\n    WARRIOR,\n    MAGE,\n    ARCHER\n}\n\nclass GameCharacter {\n    private final String name;\n    private final CharacterType type;\n    private final int baseAttack;\n\n    public GameCharacter(String name, CharacterType type, int baseAttack) {\n        this.name = name;\n        this.type = type;\n        this.baseAttack = baseAttack;\n    }\n\n    public String getName() { return name; }\n    public CharacterType getType() { return type; }\n    public int getBaseAttack() { return baseAttack; }\n}\n\nclass DamageCalculator {\n    public int calculateDamage(GameCharacter character) {\n        switch (character.getType()) {\n            case WARRIOR:\n                // Warriors hit harder but less consistent\n                return (int) (character.getBaseAttack() * 1.5);\n            case MAGE:\n                // Mages scale with a flat bonus\n                return character.getBaseAttack() + 20;\n            case ARCHER:\n                // Archers crit sometimes (simulated with random here)\n                boolean crit = new Random().nextBoolean();\n                return crit ? character.getBaseAttack() * 2 : character.getBaseAttack();\n            default:\n                throw new IllegalArgumentException(\"Unknown character type: \" + character.getType());\n        }\n    }\n}\n\n",
      "output": "import java.util.*;\n\ninterface DamageDealer {\n    int calculateDamage();\n    String getName();\n    CharacterType getType();\n}\n\nenum CharacterType {\n    WARRIOR,\n    MAGE,\n    ARCHER\n}\n\nabstract class GameCharacter implements DamageDealer {\n    private final String name;\n    private final CharacterType type;\n    private final int baseAttack;\n\n    protected GameCharacter(String name, CharacterType type, int baseAttack) {\n        this.name = name;\n        this.type = type;\n        this.baseAttack = baseAttack;\n    }\n\n    public String getName() { return name; }\n    public CharacterType getType() { return type; }\n    public int getBaseAttack() { return baseAttack; }\n}\n\nclass Warrior extends GameCharacter {\n    public Warrior(String name, int baseAttack) {\n        super(name, CharacterType.WARRIOR, baseAttack);\n    }\n\n    @Override\n    public int calculateDamage() {\n        return (int) (getBaseAttack() * 1.5);\n    }\n}\n\nclass Mage extends GameCharacter {\n    public Mage(String name, int baseAttack) {\n        super(name, CharacterType.MAGE, baseAttack);\n    }\n\n    @Override\n    public int calculateDamage() {\n        return getBaseAttack() + 20;\n    }\n}\n\nclass Archer extends GameCharacter {\n    private final Random random = new Random();\n\n    public Archer(String name, int baseAttack) {\n        super(name, CharacterType.ARCHER, baseAttack);\n    }\n\n    @Override\n    public int calculateDamage() {\n        boolean crit = random.nextBoolean();\n        return crit ? getBaseAttack() * 2 : getBaseAttack();\n    }\n}\n",
      "level": "EASY",
      "language": "JAVA",
      "violation": "OCP",
      "explanation": "DamageCalculator violates OCP because it uses a switch on CharacterType. Adding new characters like Assassin or Healer means modifying this switch block.",
          "adherence score": 2,
          "violation severity": 4
        },
    {
      "input": "import java.util.*;\n\nenum FoodType {\n    BURGER,\n    FRIES,\n    PIZZA,\n    DRINK\n}\n\nclass FoodItem {\n    private final String name;\n    private final FoodType type;\n    public FoodItem(String name, FoodType type) {\n        this.name = name; this.type = type;\n    }\n    public String getName() { return name; }\n    public FoodType getType() { return type; }\n}\n\nclass PriceCalculator {\n    public double calculatePrice(FoodItem item) {\n        switch (item.getType()) {\n            case BURGER: return 5.99;\n            case FRIES: return 2.49;\n            case PIZZA: return 7.99;\n            case DRINK: return 1.50;\n            default: throw new IllegalArgumentException(\"Unknown type\");\n        }\n    }\n}\n\nclass Order {\n    private final List<FoodItem> items = new ArrayList<>();\n    public void addItem(FoodItem item) { items.add(item); }\n    public List<FoodItem> getItems() { return items; }\n}\n\n",
      "output": "import java.util.*;\n\ninterface PricedItem {\n    String getName();\n    double getPrice();\n}\n\nabstract class FoodItem implements PricedItem {\n    private final String name;\n\n    protected FoodItem(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public String getName() { return name; }\n}\n\nclass Burger extends FoodItem {\n    public Burger(String name) { super(name); }\n    @Override public double getPrice() { return 5.99; }\n}\n\nclass Fries extends FoodItem {\n    public Fries(String name) { super(name); }\n    @Override public double getPrice() { return 2.49; }\n}\n\nclass Pizza extends FoodItem {\n    public Pizza(String name) { super(name); }\n    @Override public double getPrice() { return 7.99; }\n}\n\nclass Drink extends FoodItem {\n    public Drink(String name) { super(name); }\n    @Override public double getPrice() { return 1.50; }\n}\n\nclass Order {\n    private final List<FoodItem> items = new ArrayList<>();\n    public void addItem(FoodItem item) { items.add(item); }\n    public List<FoodItem> getItems() { return items; }\n}\n",
      "level": "EASY",
      "language": "JAVA",
      "violation": "OCP",
      "explanation": "PriceCalculator violates OCP by hard-coding prices inside a switch on FoodType. Adding new items like Salad or Dessert forces direct modification.",
          "adherence score": 2,
          "violation severity": 4
    },
    {
      "input": "import java.util.*;\n\nenum DeviceType { LIGHT, THERMOSTAT, DOOR_LOCK }\n\nclass SmartDevice {\n    private final String id;\n    private final DeviceType type;\n    public SmartDevice(String id, DeviceType type) { this.id = id; this.type = type; }\n    public String getId() { return id; }\n    public DeviceType getType() { return type; }\n}\n\nclass SmartHomeController {\n    public void turnOn(SmartDevice d) {\n        switch (d.getType()) {\n            case LIGHT: System.out.println(\"Light \" + d.getId() + \" is ON\"); break;\n            case THERMOSTAT: System.out.println(\"Thermostat \" + d.getId() + \" heating to 22°C\"); break;\n            case DOOR_LOCK: System.out.println(\"Door lock \" + d.getId() + \" cannot be turned ON\"); break;\n            default: throw new IllegalArgumentException(\"Unknown device\");\n        }\n    }\n    public double energyUsageKwh(SmartDevice d, int minutes) {\n        switch (d.getType()) {\n            case LIGHT: return 0.012 * minutes;       // ~12W bulb\n            case THERMOSTAT: return 0.08 * minutes;   // HVAC running\n            case DOOR_LOCK: return 0.0002 * minutes;  // idle electronics\n            default: throw new IllegalArgumentException(\"Unknown device\");\n        }\n    }\n}\n\n",
      "output": "import java.util.*;\n\ninterface SmartDevice {\n    String getId();\n    void turnOn();\n    double energyUsageKwh(int minutes);\n}\n\nclass Light implements SmartDevice {\n    private final String id;\n    public Light(String id) { this.id = id; }\n    public String getId() { return id; }\n\n    @Override\n    public void turnOn() {\n        System.out.println(\"Light \" + id + \" is ON\");\n    }\n\n    @Override\n    public double energyUsageKwh(int minutes) {\n        return 0.012 * minutes; // 12W bulb\n    }\n}\n\nclass Thermostat implements SmartDevice {\n    private final String id;\n    public Thermostat(String id) { this.id = id; }\n    public String getId() { return id; }\n\n    @Override\n    public void turnOn() {\n        System.out.println(\"Thermostat \" + id + \" heating to 22°C\");\n    }\n\n    @Override\n    public double energyUsageKwh(int minutes) {\n        return 0.08 * minutes; // HVAC\n    }\n}\n-\nclass DoorLock implements SmartDevice {\n    private final String id;\n    public DoorLock(String id) { this.id = id; }\n    public String getId() { return id; }\n\n    @Override\n    public void turnOn() {\n        System.out.println(\"Door lock \" + id + \" cannot be turned ON\");\n    }\n\n    @Override\n    public double energyUsageKwh(int minutes) {\n        return 0.0002 * minutes; // idle electronics\n    }\n}\n\nclass SmartHomeController {\n    public void activateDevice(SmartDevice d) {\n        d.turnOn();\n    }\n\n    public double energyUsageKwh(SmartDevice d, int minutes) {\n        return d.energyUsageKwh(minutes);\n    }\n}\n",
      "level": "EASY",
      "language": "JAVA",
      "violation": "OCP",
      "explanation": "SmartHomeController breaks OCP by using switch statements to handle each DeviceType explicitly. Adding a new device like Camera or Speaker forces controller changes.",
          "adherence score": 2,
          "violation severity": 4
    },
    {
      "input": "abstract class Entity {\n    private static long NEXT_ID = 1;\n    private final long id;\n\n    protected Entity() {\n        this.id = NEXT_ID++;\n    }\n\n    public long getId() {\n        return id;\n    }\n}\n\nabstract class GraphicObject extends Entity {\n    private final String color;\n    private final int layer;\n\n    protected GraphicObject(String color, int layer) {\n        this.color = color;\n        this.layer = layer;\n    }\n\n    public String getColor() { return color; }\n    public int getLayer()    { return layer; }\n}\n\nenum ShapeKind { RECTANGLE, CIRCLE, TRIANGLE, CUBE, SPHERE }\n\nabstract class Shape extends GraphicObject {\n    private final ShapeKind kind;\n\n    protected Shape(ShapeKind kind, String color, int layer) {\n        super(color, layer);\n        this.kind = kind;\n    }\n\n    public ShapeKind getKind() { return kind; }\n}\n\nabstract class TwoDShape extends Shape {\n    protected TwoDShape(ShapeKind kind, String color, int layer) {\n        super(kind, color, layer);\n    }\n}\n\nabstract class ThreeDShape extends Shape {\n    protected ThreeDShape(ShapeKind kind, String color, int layer) {\n        super(kind, color, layer);\n    }\n}\n\n\nclass Rectangle extends TwoDShape {\n    private final double width, height;\n\n    public Rectangle(double width, double height, String color, int layer) {\n        super(ShapeKind.RECTANGLE, color, layer);\n        this.width = width; this.height = height;\n    }\n    public double getWidth()  { return width; }\n    public double getHeight() { return height; }\n}\n\nclass Circle extends TwoDShape {\n    private final double radius;\n\n    public Circle(double radius, String color, int layer) {\n        super(ShapeKind.CIRCLE, color, layer);\n        this.radius = radius;\n    }\n    public double getRadius() { return radius; }\n}\n\nclass Triangle extends TwoDShape {\n    private final double a, b, c; // sides\n\n    public Triangle(double a, double b, double c, String color, int layer) {\n        super(ShapeKind.TRIANGLE, color, layer);\n        this.a = a; this.b = b; this.c = c;\n    }\n    public double getA() { return a; }\n    public double getB() { return b; }\n    public double getC() { return c; }\n}\n\nclass Cube extends ThreeDShape {\n    private final double edge;\n\n    public Cube(double edge, String color, int layer) {\n        super(ShapeKind.CUBE, color, layer);\n        this.edge = edge;\n    }\n    public double getEdge() { return edge; }\n}\n\nclass Sphere extends ThreeDShape {\n    private final double radius;\n\n    public Sphere(double radius, String color, int layer) {\n        super(ShapeKind.SPHERE, color, layer);\n        this.radius = radius;\n    }\n    public double getRadius() { return radius; }\n}\n\n\nenum Metric { AREA, PERIMETER, VOLUME, DIAGONAL, BOUNDING_BOX_WIDTH }\n\nclass BoundingBox {\n    public final double width;\n    public final double height;\n    public BoundingBox(double width, double height) { this.width = width; this.height = height; }\n    @Override public String toString() { return \"BBox(\" + width + \"x\" + height + \")\"; }\n}\n\nclass MetricCalculator {\n    public double compute(Shape shape, Metric metric) {\n        switch (shape.getKind()) {\n            case RECTANGLE: {\n                Rectangle r = (Rectangle) shape;\n                return switch (metric) {\n                    case AREA -> r.getWidth() * r.getHeight();\n                    case PERIMETER -> 2 * (r.getWidth() + r.getHeight());\n                    case DIAGONAL -> Math.hypot(r.getWidth(), r.getHeight());\n                    case BOUNDING_BOX_WIDTH -> r.getWidth();\n                    case VOLUME -> 0;\n                };\n            }\n            case CIRCLE: {\n                Circle c = (Circle) shape;\n                return switch (metric) {\n                    case AREA -> Math.PI * c.getRadius() * c.getRadius();\n                    case PERIMETER -> 2 * Math.PI * c.getRadius();\n                    case DIAGONAL -> 2 * c.getRadius(); // diameter\n                    case BOUNDING_BOX_WIDTH -> 2 * c.getRadius();\n                    case VOLUME -> 0;\n                };\n            }\n            case TRIANGLE: {\n                Triangle t = (Triangle) shape;\n                double s = (t.getA() + t.getB() + t.getC()) / 2.0;\n                return switch (metric) {\n                    case AREA -> Math.sqrt(Math.max(0, s * (s - t.getA()) * (s - t.getB()) * (s - t.getC())));\n                    case PERIMETER -> (t.getA() + t.getB() + t.getC());\n                    case DIAGONAL -> Math.max(t.getA(), Math.max(t.getB(), t.getC()));\n                    case BOUNDING_BOX_WIDTH -> Math.max(t.getA(), Math.max(t.getB(), t.getC())); // bogus, but consistent\n                    case VOLUME -> 0;\n                };\n            }\n            case CUBE: {\n                Cube cube = (Cube) shape;\n                return switch (metric) {\n                    case AREA -> 6 * cube.getEdge() * cube.getEdge();\n                    case PERIMETER -> 12 * cube.getEdge();\n                    case VOLUME -> Math.pow(cube.getEdge(), 3);\n                    case DIAGONAL -> Math.sqrt(3) * cube.getEdge();\n                    case BOUNDING_BOX_WIDTH -> cube.getEdge();\n                };\n            }\n            case SPHERE: {\n                Sphere s = (Sphere) shape;\n                return switch (metric) {\n                    case AREA -> 4 * Math.PI * s.getRadius() * s.getRadius();\n                    case PERIMETER -> 0; // not meaningful\n                    case VOLUME -> (4.0 / 3.0) * Math.PI * Math.pow(s.getRadius(), 3);\n                    case DIAGONAL -> 2 * s.getRadius(); // diameter\n                    case BOUNDING_BOX_WIDTH -> 2 * s.getRadius();\n                };\n            }\n            default: return 0;\n        }\n    }\n}\n\nclass ShapeValidator {\n    public boolean isValid(Shape shape) {\n        switch (shape.getKind()) {\n            case RECTANGLE: {\n                Rectangle r = (Rectangle) shape;\n                return r.getWidth() > 0 && r.getHeight() > 0;\n            }\n            case CIRCLE: {\n                Circle c = (Circle) shape;\n                return c.getRadius() > 0;\n            }\n            case TRIANGLE: {\n                Triangle t = (Triangle) shape;\n                return t.getA() > 0 && t.getB() > 0 && t.getC() > 0\n                    && t.getA() + t.getB() > t.getC()\n                    && t.getA() + t.getC() > t.getB()\n                    && t.getB() + t.getC() > t.getA();\n            }\n            case CUBE: {\n                Cube cube = (Cube) shape;\n                return cube.getEdge() > 0;\n            }\n            case SPHERE: {\n                Sphere s = (Sphere) shape;\n                return s.getRadius() > 0;\n            }\n            default: return false;\n        }\n    }\n}\n\nclass ShapeRenderer {\n    public String renderPseudoSvg(Shape shape) {\n        switch (shape.getKind()) {\n            case RECTANGLE: {\n                Rectangle r = (Rectangle) shape;\n                return \"<rect w=\\\"\" + r.getWidth() + \"\\\" h=\\\"\" + r.getHeight()\n                        + \"\\\" fill=\\\"\" + shape.getColor() + \"\\\" layer=\\\"\" + shape.getLayer() + \"\\\"/>\";\n            }\n            case CIRCLE: {\n                Circle c = (Circle) shape;\n                return \"<circle r=\\\"\" + c.getRadius()\n                        + \"\\\" fill=\\\"\" + shape.getColor() + \"\\\" layer=\\\"\" + shape.getLayer() + \"\\\"/>\";\n            }\n            case TRIANGLE: {\n                Triangle t = (Triangle) shape;\n                return \"<polygon a=\\\"\" + t.getA() + \"\\\" b=\\\"\" + t.getB() + \"\\\" c=\\\"\" + t.getC()\n                        + \"\\\" fill=\\\"\" + shape.getColor() + \"\\\" layer=\\\"\" + shape.getLayer() + \"\\\"/>\";\n            }\n            case CUBE: {\n                Cube cube = (Cube) shape;\n                return \"<cube edge=\\\"\" + cube.getEdge()\n                        + \"\\\" materialColor=\\\"\" + shape.getColor() + \"\\\" layer=\\\"\" + shape.getLayer() + \"\\\"/>\";\n            }\n            case SPHERE: {\n                Sphere s = (Sphere) shape;\n                return \"<sphere r=\\\"\" + s.getRadius()\n                        + \"\\\" materialColor=\\\"\" + shape.getColor() + \"\\\" layer=\\\"\" + shape.getLayer() + \"\\\"/>\";\n            }\n            default: return \"<unknown/>\";\n        }\n    }\n}\n\nclass ShapeSerializer {\n    public String toCsvRow(Shape shape) {\n        switch (shape.getKind()) {\n            case RECTANGLE: {\n                Rectangle r = (Rectangle) shape;\n                return \"rectangle,\" + r.getWidth() + \",\" + r.getHeight() + \",\" + shape.getColor() + \",\" + shape.getLayer();\n            }\n            case CIRCLE: {\n                Circle c = (Circle) shape;\n                return \"circle,\" + c.getRadius() + \",\" + shape.getColor() + \",\" + shape.getLayer();\n            }\n            case TRIANGLE: {\n                Triangle t = (Triangle) shape;\n                return \"triangle,\" + t.getA() + \",\" + t.getB() + \",\" + t.getC() + \",\" + shape.getColor() + \",\" + shape.getLayer();\n            }\n            case CUBE: {\n                Cube cube = (Cube) shape;\n                return \"cube,\" + cube.getEdge() + \",\" + shape.getColor() + \",\" + shape.getLayer();\n            }\n            case SPHERE: {\n                Sphere s = (Sphere) shape;\n                return \"sphere,\" + s.getRadius() + \",\" + shape.getColor() + \",\" + shape.getLayer();\n            }\n            default: return \"unknown\";\n        }\n    }\n}\n\nclass ShapeFactory {\n    public Shape create(String spec) {\n        String[] parts = spec.split(\";\");\n        String type = parts[0].trim().toLowerCase();\n        java.util.Map<String,String> map = new java.util.HashMap<>();\n        for (int i = 1; i < parts.length; i++) {\n            String[] kv = parts[i].split(\"=\");\n            if (kv.length == 2) map.put(kv[0].trim().toLowerCase(), kv[1].trim());\n        }\n        String color = map.getOrDefault(\"color\", \"black\");\n        int layer = Integer.parseInt(map.getOrDefault(\"layer\", \"0\"));\n\n        switch (type) {\n            case \"rectangle\":\n                return new Rectangle(\n                    Double.parseDouble(map.getOrDefault(\"width\",\"0\")),\n                    Double.parseDouble(map.getOrDefault(\"height\",\"0\")),\n                    color, layer\n                );\n            case \"circle\":\n                return new Circle(\n                    Double.parseDouble(map.getOrDefault(\"radius\",\"0\")),\n                    color, layer\n                );\n            case \"triangle\":\n                return new Triangle(\n                    Double.parseDouble(map.getOrDefault(\"a\",\"0\")),\n                    Double.parseDouble(map.getOrDefault(\"b\",\"0\")),\n                    Double.parseDouble(map.getOrDefault(\"c\",\"0\")),\n                    color, layer\n                );\n            case \"cube\":\n                return new Cube(\n                    Double.parseDouble(map.getOrDefault(\"edge\",\"0\")),\n                    color, layer\n                );\n            case \"sphere\":\n                return new Sphere(\n                    Double.parseDouble(map.getOrDefault(\"radius\",\"0\")),\n                    color, layer\n                );\n            default:\n                throw new IllegalArgumentException(\"Unknown shape type: \" + type);\n        }\n    }\n}\n\nclass ShapePricing {\n    private final MetricCalculator calc = new MetricCalculator();\n\n    public double price(Shape shape) {\n        switch (shape.getKind()) {\n            case RECTANGLE: {\n                double area = calc.compute(shape, Metric.AREA);\n                return 0.5 * area + shape.getLayer() * 2;\n            }\n            case CIRCLE: {\n                double area = calc.compute(shape, Metric.AREA);\n                double diag = calc.compute(shape, Metric.DIAGONAL);\n                return 0.6 * area + 0.1 * diag;\n            }\n            case TRIANGLE: {\n                double per = calc.compute(shape, Metric.PERIMETER);\n                return per * 0.8;\n            }\n            case CUBE: {\n                double vol = calc.compute(shape, Metric.VOLUME);\n                return 1.2 * vol;\n            }\n            case SPHERE: {\n                double vol = calc.compute(shape, Metric.VOLUME);\n                return 1.0 * vol + 10;\n            }\n            default: return 0;\n        }\n    }\n}\n\nclass LegendBuilder {\n    public String legendSymbol(Shape shape) {\n        switch (shape.getKind()) {\n            case RECTANGLE: return \"▭\";\n            case CIRCLE:    return \"◯\";\n            case TRIANGLE:  return \"△\";\n            case CUBE:      return \"⬛\";\n            case SPHERE:    return \"◯\";\n            default:        return \"?\";\n        }\n    }\n}\n\nclass CollisionEngine {\n    public BoundingBox boundingBox(Shape shape) {\n        switch (shape.getKind()) {\n            case RECTANGLE: {\n                Rectangle r = (Rectangle) shape;\n                return new BoundingBox(r.getWidth(), r.getHeight());\n            }\n            case CIRCLE: {\n                Circle c = (Circle) shape;\n                double d = 2 * c.getRadius();\n                return new BoundingBox(d, d);\n            }\n            case TRIANGLE: {\n                Triangle t = (Triangle) shape;\n                // naive placeholder: longest side × (average of other sides)\n                double max = Math.max(t.getA(), Math.max(t.getB(), t.getC()));\n                double avg = (t.getA() + t.getB() + t.getC() - max) / 2.0;\n                return new BoundingBox(max, avg);\n            }\n            case CUBE: {\n                Cube cube = (Cube) shape;\n                return new BoundingBox(cube.getEdge(), cube.getEdge());\n            }\n            case SPHERE: {\n                Sphere s = (Sphere) shape;\n                double d = 2 * s.getRadius();\n                return new BoundingBox(d, d);\n            }\n            default: return new BoundingBox(0, 0);\n        }\n    }\n\n    public boolean overlaps(Shape a, Shape b) {\n        BoundingBox A = boundingBox(a);\n        BoundingBox B = boundingBox(b);\n        return (A.width * A.height) > 0 && (B.width * B.height) > 0;\n    }\n}\n\nclass ShapeReport {\n    private final MetricCalculator calc = new MetricCalculator();\n    private final ShapeSerializer ser = new ShapeSerializer();\n    private final ShapeRenderer rnd = new ShapeRenderer();\n    private final CollisionEngine col = new CollisionEngine();\n    private final ShapePricing price = new ShapePricing();\n    private final LegendBuilder legend = new LegendBuilder();\n\n    public String summarize(java.util.List<Shape> shapes) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"=== Shape Report (OCP-violating) ===\\n\");\n        for (Shape s : shapes) {\n            sb.append(\"ID \").append(s.getId())\n              .append(\" \").append(s.getKind())\n              .append(\" color=\").append(s.getColor())\n              .append(\" layer=\").append(s.getLayer()).append(\"\\n\");\n\n            sb.append(\"  CSV: \").append(ser.toCsvRow(s)).append(\"\\n\");\n            sb.append(\"  SVG: \").append(rnd.renderPseudoSvg(s)).append(\"\\n\");\n            sb.append(\"  Legend: \").append(legend.legendSymbol(s)).append(\"\\n\");\n\n            sb.append(\"  Metrics: \");\n            sb.append(\" area=\").append(calc.compute(s, Metric.AREA));\n            sb.append(\" perim=\").append(calc.compute(s, Metric.PERIMETER));\n            sb.append(\" diag=\").append(calc.compute(s, Metric.DIAGONAL));\n            if (s instanceof ThreeDShape) {\n                sb.append(\" vol=\").append(calc.compute(s, Metric.VOLUME));\n            }\n            sb.append(\"\\n\");\n\n            sb.append(\"  BBox: \").append(col.boundingBox(s)).append(\"\\n\");\n            sb.append(\"  Price: \").append(price.price(s)).append(\"\\n\\n\");\n        }\n        return sb.toString();\n    }\n}\n",
      "output": "import java.util.*;\nimport java.util.function.Function;\n\nabstract class Entity {\n    private static long NEXT_ID = 1;\n    private final long id;\n    protected Entity() { this.id = NEXT_ID++; }\n    public long getId() { return id; }\n}\n\nabstract class GraphicObject extends Entity {\n    private final String color;\n    private final int layer;\n    protected GraphicObject(String color, int layer) { this.color = color; this.layer = layer; }\n    public String getColor() { return color; }\n    public int getLayer() { return layer; }\n}\n\nenum ShapeKind { RECTANGLE, CIRCLE, TRIANGLE, CUBE, SPHERE }\n\nfinal class BoundingBox {\n    public final double width;\n    public final double height;\n    public BoundingBox(double width, double height) { this.width = width; this.height = height; }\n    @Override public String toString() { return \"BBox(\" + width + \"x\" + height + \")\"; }\n}\n\ninterface HasWidthHeight { double getWidth(); double getHeight(); }\ninterface HasRadius { double getRadius(); }\ninterface HasTriangleSides { double getA(); double getB(); double getC(); }\ninterface HasEdge { double getEdge(); }\n\nabstract class Shape extends GraphicObject {\n    private final ShapeKind kind;\n    protected Shape(ShapeKind kind, String color, int layer) { super(color, layer); this.kind = kind; }\n    public ShapeKind getKind() { return kind; }\n    public abstract boolean isValid();\n    public abstract String renderPseudoSvg();\n    public abstract String toCsvRow();\n    public abstract String legendSymbol();\n    public abstract BoundingBox boundingBox();\n    public abstract double price(MetricCalculator calc);\n}\n\nabstract class TwoDShape extends Shape {\n    protected TwoDShape(ShapeKind kind, String color, int layer) { super(kind, color, layer); }\n}\nabstract class ThreeDShape extends Shape {\n    protected ThreeDShape(ShapeKind kind, String color, int layer) { super(kind, color, layer); }\n}\n\nfinal class Rectangle extends TwoDShape implements HasWidthHeight {\n    private final double width, height;\n    public Rectangle(double width, double height, String color, int layer) { super(ShapeKind.RECTANGLE, color, layer); this.width = width; this.height = height; }\n    public double getWidth() { return width; }\n    public double getHeight() { return height; }\n    public boolean isValid() { return width > 0 && height > 0; }\n    public String renderPseudoSvg() { return \"<rect w=\\\"\" + width + \"\\\" h=\\\"\" + height + \"\\\" fill=\\\"\" + getColor() + \"\\\" layer=\\\"\" + getLayer() + \"\\\"/>\"; }\n    public String toCsvRow() { return \"rectangle,\" + width + \",\" + height + \",\" + getColor() + \",\" + getLayer(); }\n    public String legendSymbol() { return \"▭\"; }\n    public BoundingBox boundingBox() { return new BoundingBox(width, height); }\n    public double price(MetricCalculator calc) {\n        double area = calc.compute(this, \"area\");\n        return 0.5 * area + getLayer() * 2;\n    }\n}\n\nfinal class Circle extends TwoDShape implements HasRadius {\n    private final double radius;\n    public Circle(double radius, String color, int layer) { super(ShapeKind.CIRCLE, color, layer); this.radius = radius; }\n    public double getRadius() { return radius; }\n    public boolean isValid() { return radius > 0; }\n    public String renderPseudoSvg() { return \"<circle r=\\\"\" + radius + \"\\\" fill=\\\"\" + getColor() + \"\\\" layer=\\\"\" + getLayer() + \"\\\"/>\"; }\n    public String toCsvRow() { return \"circle,\" + radius + \",\" + getColor() + \",\" + getLayer(); }\n    public String legendSymbol() { return \"◯\"; }\n    public BoundingBox boundingBox() { double d = 2 * radius; return new BoundingBox(d, d); }\n    public double price(MetricCalculator calc) {\n        double area = calc.compute(this, \"area\");\n        double diag = calc.compute(this, \"diagonal\");\n        return 0.6 * area + 0.1 * diag;\n    }\n}\n\nfinal class Triangle extends TwoDShape implements HasTriangleSides {\n    private final double a, b, c;\n    public Triangle(double a, double b, double c, String color, int layer) { super(ShapeKind.TRIANGLE, color, layer); this.a = a; this.b = b; this.c = c; }\n    public double getA() { return a; } public double getB() { return b; } public double getC() { return c; }\n    public boolean isValid() { return a > 0 && b > 0 && c > 0 && a + b > c && a + c > b && b + c > a; }\n    public String renderPseudoSvg() { return \"<polygon a=\\\"\" + a + \"\\\" b=\\\"\" + b + \"\\\" c=\\\"\" + c + \"\\\" fill=\\\"\" + getColor() + \"\\\" layer=\\\"\" + getLayer() + \"\\\"/>\"; }\n    public String toCsvRow() { return \"triangle,\" + a + \",\" + b + \",\" + c + \",\" + getColor() + \",\" + getLayer(); }\n    public String legendSymbol() { return \"△\"; }\n    public BoundingBox boundingBox() { double max = Math.max(a, Math.max(b, c)); double avg = (a + b + c - max) / 2.0; return new BoundingBox(max, avg); }\n    public double price(MetricCalculator calc) {\n        double per = calc.compute(this, \"perimeter\");\n        return per * 0.8;\n    }\n}\n\nfinal class Cube extends ThreeDShape implements HasEdge {\n    private final double edge;\n    public Cube(double edge, String color, int layer) { super(ShapeKind.CUBE, color, layer); this.edge = edge; }\n    public double getEdge() { return edge; }\n    public boolean isValid() { return edge > 0; }\n    public String renderPseudoSvg() { return \"<cube edge=\\\"\" + edge + \"\\\" materialColor=\\\"\" + getColor() + \"\\\" layer=\\\"\" + getLayer() + \"\\\"/>\"; }\n    public String toCsvRow() { return \"cube,\" + edge + \",\" + getColor() + \",\" + getLayer(); }\n    public String legendSymbol() { return \"⬛\"; }\n    public BoundingBox boundingBox() { return new BoundingBox(edge, edge); }\n    public double price(MetricCalculator calc) {\n        double vol = calc.compute(this, \"volume\");\n        return 1.2 * vol;\n    }\n}\n\nfinal class Sphere extends ThreeDShape implements HasRadius {\n    private final double radius;\n    public Sphere(double radius, String color, int layer) { super(ShapeKind.SPHERE, color, layer); this.radius = radius; }\n    public double getRadius() { return radius; }\n    public boolean isValid() { return radius > 0; }\n    public String renderPseudoSvg() { return \"<sphere r=\\\"\" + radius + \"\\\" materialColor=\\\"\" + getColor() + \"\\\" layer=\\\"\" + getLayer() + \"\\\"/>\"; }\n    public String toCsvRow() { return \"sphere,\" + radius + \",\" + getColor() + \",\" + getLayer(); }\n    public String legendSymbol() { return \"◯\"; }\n    public BoundingBox boundingBox() { double d = 2 * radius; return new BoundingBox(d, d); }\n    public double price(MetricCalculator calc) {\n        double vol = calc.compute(this, \"volume\");\n        return 1.0 * vol + 10;\n    }\n}\n\nfinal class RegisteredMetric {\n    private final String name;\n    private final Map<Class<?>, Function<Object, Double>> handlers = new LinkedHashMap<>();\n    public RegisteredMetric(String name) { this.name = name; }\n    public String name() { return name; }\n    public <T> RegisteredMetric on(Class<T> type, Function<T, Double> fn) { handlers.put(type, o -> fn.apply(type.cast(o))); return this; }\n    public double apply(Shape s) {\n        for (Map.Entry<Class<?>, Function<Object, Double>> e : handlers.entrySet()) {\n            if (e.getKey().isInstance(s)) return e.getValue().apply(s);\n        }\n        return 0;\n    }\n}\n\nfinal class MetricCalculator {\n    private final Map<String, RegisteredMetric> metrics = new HashMap<>();\n    public void register(RegisteredMetric metric) { metrics.put(metric.name(), metric); }\n    public double compute(Shape shape, String metricName) {\n        RegisteredMetric m = metrics.get(metricName);\n        if (m == null) throw new IllegalArgumentException(\"Unknown metric: \" + metricName);\n        return m.apply(shape);\n    }\n}\n\nfinal class ShapeValidator { public boolean isValid(Shape shape) { return shape.isValid(); } }\nfinal class ShapeRenderer { public String renderPseudoSvg(Shape shape) { return shape.renderPseudoSvg(); } }\nfinal class ShapeSerializer { public String toCsvRow(Shape shape) { return shape.toCsvRow(); } }\n\nfinal class ShapeFactory {\n    interface Creator { Shape create(Map<String,String> map, String color, int layer); }\n    private final Map<String, Creator> creators = new HashMap<>();\n    public void register(String type, Creator c) { creators.put(type.toLowerCase(), c); }\n    public Shape create(String spec) {\n        String[] parts = spec.split(\";\");\n        String type = parts[0].trim().toLowerCase();\n        Map<String,String> map = new HashMap<>();\n        for (int i = 1; i < parts.length; i++) {\n            String[] kv = parts[i].split(\"=\");\n            if (kv.length == 2) map.put(kv[0].trim().toLowerCase(), kv[1].trim());\n        }\n        String color = map.getOrDefault(\"color\", \"black\");\n        int layer = Integer.parseInt(map.getOrDefault(\"layer\", \"0\"));\n        Creator c = creators.get(type);\n        if (c == null) throw new IllegalArgumentException(\"Unknown shape type: \" + type);\n        return c.create(map, color, layer);\n    }\n}\n\nfinal class ShapePricing {\n    private final MetricCalculator calc;\n    public ShapePricing(MetricCalculator calc) { this.calc = calc; }\n    public double price(Shape shape) { return shape.price(calc); }\n}\n\nfinal class LegendBuilder { public String legendSymbol(Shape shape) { return shape.legendSymbol(); } }\n\nfinal class CollisionEngine {\n    public BoundingBox boundingBox(Shape shape) { return shape.boundingBox(); }\n    public boolean overlaps(Shape a, Shape b) {\n        BoundingBox A = boundingBox(a);\n        BoundingBox B = boundingBox(b);\n        return (A.width * A.height) > 0 && (B.width * B.height) > 0;\n    }\n}\n\nfinal class ShapeReport {\n    private final MetricCalculator calc;\n    private final ShapeSerializer ser = new ShapeSerializer();\n    private final ShapeRenderer rnd = new ShapeRenderer();\n    private final CollisionEngine col = new CollisionEngine();\n    private final ShapePricing price;\n    private final LegendBuilder legend = new LegendBuilder();\n    public ShapeReport(MetricCalculator calc) { this.calc = calc; this.price = new ShapePricing(calc); }\n    public String summarize(List<Shape> shapes) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"=== Shape Report (OCP-violating) ===\\n\");\n        for (Shape s : shapes) {\n            sb.append(\"ID \").append(s.getId())\n              .append(\" \").append(s.getKind())\n              .append(\" color=\").append(s.getColor())\n              .append(\" layer=\").append(s.getLayer()).append(\"\\n\");\n\n            sb.append(\"  CSV: \").append(ser.toCsvRow(s)).append(\"\\n\");\n            sb.append(\"  SVG: \").append(rnd.renderPseudoSvg(s)).append(\"\\n\");\n            sb.append(\"  Legend: \").append(legend.legendSymbol(s)).append(\"\\n\");\n\n            sb.append(\"  Metrics: \");\n            sb.append(\" area=\").append(calc.compute(s, \"area\"));\n            sb.append(\" perim=\").append(calc.compute(s, \"perimeter\"));\n            sb.append(\" diag=\").append(calc.compute(s, \"diagonal\"));\n            if (s instanceof ThreeDShape) {\n                sb.append(\" vol=\").append(calc.compute(s, \"volume\"));\n            }\n            sb.append(\"\\n\");\n\n            sb.append(\"  BBox: \").append(col.boundingBox(s)).append(\"\\n\");\n            sb.append(\"  Price: \").append(price.price(s)).append(\"\\n\\n\");\n        }\n        return sb.toString();\n    }\n}\n",
      "level": "HARD",
      "language": "JAVA",
      "violation": "OCP",
      "explanation": "The ShapeReport and related classes violate OCP because they use nested switch statements on ShapeKind and Metric across multiple components. Every new shape or metric requires editing many files.",
          "adherence score": 1,
          "violation severity": 5
    }
  ]
}
